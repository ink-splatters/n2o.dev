.TH kvs_stream 1 "kvs_stream" "Synrc Research Center" "STREAM"
.SH NAME
kvs_stream

.SH ВСТУП
.LP
Модуль STREAM пропонує інтерфейс фолдів, акумуляторів за персистентного зберігання ланцюжків даних.
.LP
.LP
\fIwriter/1\fR\& — створює та повертає курсор запису до бази даних.
\fIreader/1\fR\& — створює та повертає курсор зчитування до бази даних.
\fIsave/1\fR\& — зберігає курсор до бази даних.
\fIload_reader/1\fR\& — підзавантажує збережений курсор зчитування.
\fIload_writer/1\fR\& — підзавантажує збережений курсор запису.
\fItop/1\fR\& — повертає початок (вершину) ланцюжка.
\fIbot/1\fR\& — повертає закінчення (основу) ланцюжка.
\fInext/1\fR\& — переміщає курсор зчитування на наступний елемент.
\fIprev/1\fR\& — переміщає курсор зчитування на попередній елемент.
\fItake/1\fR\& — повертає N елементів з курсору зчитування.
\fIdrop/1\fR\& — пропускає N елементів з курсору зчитування.
\fIadd/1\fR\& — додає елемент до списку.
\fIappend/2\fR\& — додає елемент в канал.
\fIcut/2\fR\& — очищає канал до заданої мітки timestamp.
.LP
Ви може взяти
\fIkvs_stream\fR\& і використовувати у своїх додатках без імпортування залежності
synrc/kvs
,
оскільки даний модуль є самодостатнім.
Додатками можуть бути: публічні та приватні канали/стрічки новин, FIFO черги,
непрочитані повідомлення, чат, блокчейн etc.

.SH WRITER
.LP
Курсор запису передставляє собою додавання деяких кешованих значень до списку-ланцюжка.
Наприклад, розмір ланцюжка, перший елемент ланцюжка, кешоване значення
попереднього записаного повідомлення, та поле для передачі аргументів stream функціям, таким, як add.
.nf
-record(writer, { id    = [] :: term(),
count =  0 :: integer(),
cache = [] :: [] | tuple(),
args  = [] :: term(),
first = [] :: [] | tuple() } ).
.fi
.LP
Щоб додати дані до бази даних, спочатку потрібно створити курсор запису,
встановити запис з мета-інформацією в поле аргументів, та викликати функцію save.
writer(term()) -> #writer{}.
.LP
Створює курсор запису.
add(#writer{}) -> #writer{}.
.LP
Додає елемент до списку, на який вказує курсор запису.
load_writer(#writer{}) -> #writer{}.
.LP
Підзавантажує курсор запису.
save(#writer{}) -> #writer{}.
.LP
Переміщує курсор запису до бази даних.

.SH READER
.nf
-record(reader, { id    = [] :: integer(),
pos   =  0 :: [] | integer(),
cache = [] :: [] | integer(),
args  = [] :: term(),
feed  = [] :: term(),
dir   =  0 :: 0 | 1 } ).
.fi
reader(integer()) -> #reader{}.
.LP
Створює курсор зчитування.
load_reader(#reader{}) -> #reader{}.
.LP
Підзавантажує курсор зчитування з бази даних.
save(#reader{}) -> #reader{}.
.LP
Переміщує курсор зчитування до бази даних.
top(#reader{}) -> #reader{}.
.LP
Переміщає курсор в початок (вершину) списку.
bot(#reader{}) -> #reader{}.
.LP
Переміщає курсор в закінчення (основу) списку.

.SH ITER
.nf
-record(iter,   { id    = [] :: [] | integer(),
next  = [] :: [] | integer(),
prev  = [] :: [] | integer() } ).
.fi
next(#reader{}) -> #reader{}.
.LP
Переміщає курсор на наступний елемент. Споживає дані з вершини.
Повертає помилку, якщо список є пустим, в іншому випадку — наступний чи останній елемент.
prev(#reader{}) -> #reader{}.
.LP
Переміщає курсор на попередній елемент. Споживає дані з основи.
Повертає помилку, якщо список є пустим, в іншому випадку — наступний чи останній елемент.
drop(#reader{}) -> #reader{}.
.LP
Пропускає N елементів, розпочинаючи з курсора.
take(#reader{}) -> #reader{}.
.LP
Пробує споживати N записів зі stream, використовуючи його поточне значення та напрям.
Повертає споживані дані. Зазвичай ви шукаєте певну позицію, і далі споживаєте деякі дані.

.SH ALSO
.L